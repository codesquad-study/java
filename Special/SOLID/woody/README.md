# OOP와 SOLID 원칙



## OOP의 특징

- Encapsulation
- Inheritance
- Abstraction
- Polymorphism

## Solid 원칙

- Single Responsibility Principle
- Open / Closed Principle
- Liskov's Substitution Principle
- Interface Segregation Principle
- Dipendency Inversion Principle



### 객체 지향의 특징

**객체 지향 프로그래밍이란?**

필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만들고, 객체 간의 상호작용을 통해 프로그램의 흐름을 만들어내는 패러다임을 말한다.

객체 지향에서 가장 중요한 것은 객체보다, 객체 간의 협력이다. 프로그램에서 정적인 상태의 객체 그 자체로는 아무런 의미가 없다. 객체가 서로 상호작용을 하면서 우리가 원하는, 의도하는 결과물을 뱉어낸다. 때문에 객체 지향적으로 설계를 하기 위해서는 클래스 구현보다도 어떤 행동이 필요한지 그리고 그 행동을 위해서는 어떤 데이터가 필요한지를 먼저 결정한 다음 클래스에 대해 생각해보는 것이 더 적절하다. 이 과정에서 어떤 클래스 혹은 객체가 특정 행동을 맡아야 하는지 즉, 책임 분배에 관한 논의가 필요하다. 올바른 책임을 올바른 객체에 할당해야 각 객체가 자율적이면서도 협력적인 객체를 만들어낼 수 있다.

한 마디로, 객체지향에서는 클래스를 중심으로 두는게 아니라, 메시지를 주고받는 동적인 객체들을 중심에 두어야 한다.

객체 지향 프로그래밍 VS 절차 지향 프로그래밍

- 객체 지향 프로그래밍은 객체가 실행 시간에 메서드를 선택하지만, 절차지향의 경우 실행 코드를 컴파일 시간에 결정한다.
- 역할과 구현을 분리한다
  - 단순한 구현이 가능해진다.
  - 유연한 구조를 가질 수 있게 되고, 변경이 편리해진다.

**객체란?**

하나의 유의미한 개념 단위로 속성과 행위를 분류하고 이를 변수와 메소드로 정의한 것이 클래스이다.

해당 클래스가 실제 값을 가지고 메모리에 할당된다면 그게 인스턴스, 객체이다.

**다형성이란?**

서로 다른 객체가 같은 요청에 대해 다른 방식으로 응답할 수 있는 성질을 말한다. 객체 지향에서 유연한 설계, 재사용성을 가능하게 해주는(변경에 따른 파급효과를 줄여주는) 중요한 요소 중 하나이다. 가장 큰 이유는 객체와 요청(메시지)간의 결합도를 낮출 수 있다는 점 때문이다. 다형성을 사용하면 객체들이 서로 대체될 수 있기 때문에 요청(메시지)하는 클래스를 캡슐화해서 요청을 받은 클래스는 행위에만 집중할 수 있도록 만들어준다.

- 다형성을 이용하면 인터페이스로 구현한 객체 인스턴스를 실행시점에서 유연하게 변경 가능하다.

**캡슐화란**?

외부에는 행동만을 제공하고 데이터는 감추는 것.

**상속이란?**

부모클래스(슈퍼타입)의 속성, 행위를 상속받고 자신만의 추가적인 속성을 더해 자식 클래스(서브타입)를 만들어낸다. 서브타입은 슈퍼타입의 기본적인 속성을 모두 공유한다. (이런 특징으로 인해 슈퍼타입은 서브타입으로 언제든 대체될 수 있다)

**추상화란?**

서로 다른 속성, 행위 속에서 공통된 것들만을 뽑아내서 일반화시키는 과정을 추상화라고 한다.

### SOLID 원칙

**Single Responsibility Principle** 단일 책임 원칙

- 하나의 **클래스**는 하나의 책임만 가져야 한다.
- 단일 책임 원칙이 잘 지켜진 코드는 변경에 대해 파급효과가 적다.

단일 책임 원칙은 말 그대로 클래스가 하나의 책임 만을 가져야 한다는 것이다. 하나의 클래스가 여러가지 책임을 한 번에 가지고 있다보면 여러 기능들의 결합도가 높아지게 된다. 때문에 하나의 변경 사항에 대해 사이드 이펙트가  매우 크게 작용해서 바꾸고 싶지 않았던 부분들 까지도 변경해야하는 불상사가 생기게 된다. 이렇게 되면 코드 흐름을 읽기가 힘들어지고, 유지보수에 많은 시간이 걸리게 된다.

일상 생활에서도 마찬가지다. 내가 단일 책임 원칙을 지키지 않게되면 만능 플레이어가 되어야 하는데, 정말 피곤하지 않을까. 여러가지를 한 번에 하다보면 일정이 빡빡하다보니 도중에 갑자기 A일을 하게되어야 할 상황이 왔을 때 스케줄이 다 밀려버리는 대참사가 일어날 수도 있다.

**Open / Closed Principle** OCP 개방 폐쇄 원칙

- 확장에는 열려있고 변경에는 닫혀있어야 한다.
- 다형성을 통해서 얻을 수 있다.

일단 SRP를 지키게 되면 OCP를 지키기 쉬워진다. 위에서 말한대로 역할을 분산하게 된다면 기능들 간의 결합도가 낮아지기 때문에 변경에 닫혀있는 구조를 만들 수 있기 때문이다. 내가 변경하고 싶은 부분만 딱! 변경할 수 있으니까.

확장성을 지키기 위한 좋은 도구는 다형성이다. 아래의 다형성을 통해서 확장성을 확보한 예시이다. MemberService 클래스 내부에서 MemberRespository의 타입이 명시적으로 드러나있게 되면 해당 타입에 대한 의존성이 생기게 된다. 즉, new MemoryMemberRepository();라고 명시적으로 assign하게 되면 해당 클래스는 MemoryMemberRepository 밖에 사용할 수 없게 된다. JDBCRepository와 같이 다른 객체로 변경하고 싶을 때는 코드를 수정해야 한다. 확장과  유연한 변경 모두 꽝이다.

메소드 파라미터로 주입을 하는 방식으로 변경하면 선언 타입에 대한 의존성이 사라진다. 일단 명시적으로 다른 클래스들이 선언된 부분이 사라진 것만 봐도 알 수 있다. 이제 MemberService 클래스는 MemoryMemberRepository 혹은 JDBCRepository와 같은 자식 클래스들로부터 독립적일 수 있게 되었다. 의존성을 주입하고 싶다면 MemberService를 인스턴스화할 때 파라미터에 의존성을 주입하면 끝이다. 의존성이 바뀌더라도 상관없다. 이제야 확장성과 유연한 변경 두 마리 토끼를 잡을 수 있게 되었따❤️

```java
public class MemberService {
   private MemberRespository rep = new MemoryMemberRepository();
   // 만약 JDBCRepository로 바꾸고 싶다면 코드를 아래와 같이 수정해야한다.
   // OCP 원칙을 깨는 구조 이면서 동시에 DIP 원칙에도 위반
   // MemberRepository가 구현 클래스에 의존하고 있기 때문이다.
   private MemberRespository rep = new JDBCRepository(); 
}

public class MemberService {
   private MemberRespository rep;
   // 다형성을 활용해서 코드 변경없이 더 유연하게 JDBCRepository로 변경할 수 있게 되었다.
   // 코드 변경에는 닫혀있고, 확장에는 열려있으므로 OCP 원칙을 지킬 수 있다.
   public MemberService (MemberRespository rep) {
      this.rep = rep;
   }
}
```

**Liskov Substitution Principle** 리스코프 치환 원칙

- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
- 구조적인 원칙 뿐만 아니라 기능적인 원칙까지 지켜야 한다.

리스코프 치환 원칙을 지키기 위해서 하위 클래스는 상위 클래스를 치환할 때에도 여전히 성립해야 한다. 상위 클래스가 하위 클래스들이 공통적인 기능부만을 혹은 추상화할 필요가 있는 기능들을 가지고 있다. 때문에 리스코프 치환원칙을 지킨 클래스들의 경우 하위 클래스는 항상 상위클래스와 같거나 혹은 더 많은 기능들을 가지고 있다.

(-) 아직 LSP의 효용성에 대해서 명확히 알기 힘들지만, List<> = new ArrayList<() 처럼 다형성을 적용할 때 지켜야하는 원칙과 같은 느낌이 아닐까 생각한다. 자바에서는 이미 컴파일러를 통해 어느정도 LSP가 강제 되어있는 것 같다는 느낌이 든다. 자바에서는 당연히 지켜야 하는 느낌..?

**Interface Segregation Principle** ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 책임 소재를 분리하는 느낌 OOP를 지키다보면 당연히 지켜질 수 밖에 없는 원칙

클라이언트는 자신에게 필요한 인터페이스에만 의존적이어야 한다. 자신이 사용하지 않는 인터페이스에게 까지 의존적일 필요가 없고 그래서도 안된다. 책임이 몰빵된 인터페이스를 사용하려고 한다면 해당 인터페이스를 상속받을 경우 인터페이스에 딸려있는 메소드들을 불필요하게 모두 오버라이드 해야하는 경우가 발생할 수도 있다. 또한 이 거대한 인터페이스가 변경 되었을 경우, 해당 인터페이스에 의존적이었던 코드들을 모오두 수정해주어야 하는데 유지보수에 시간을 많이 보내야 한다는 단점도 있다. 단일 책임 원칙과 연계해보면 인터페이스 또한 하나의 책임을 가지도록 분리를 해야하는 것이 자연스럽다.

**Dependency Inversion Principle** DIP 의존관계 역전 원칙

- 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.
- 즉, 역할에 의존해야 좀 더 유연하게 구현체를 변경할 수 있다.

구현부보다 추상화된 부분에 더 의존적 이어야 한다는 말이다. 다시 말해 구현 클래스 보다는 인터페이스에 의존해야한다.

### 참고

1. [링크] 객체지향 프로그래밍이 뭔가요? - [참고 링크](https://jeong-pro.tistory.com/95)
2. [책] 객체지향의 사실과 오해 - 조영호
3. [강의] 스프링 핵심 원리 - 기본편 (김영한님 강의) 중 좋은 객체 지향 설계의 5가지 원칙 참고